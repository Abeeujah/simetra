import { shippingAddressSchema } from "../../schemas/address.schema.js";
import {
  amountQuery,
  checkout,
  completedOrders,
  orderCompleted,
  orderHistory,
  paymentUpdate,
  shippingAddress,
} from "../../services/order.services.js";
import { validationErrorBuilder } from "../../utils/validation.util.js";

export async function httpCheckout(req, res) {
  try {
    const { id } = req.user;
    const { items } = req.body;
    const check = await checkout(id, items);
    res
      .status(200)
      .json({ success: true, message: "Checkout initiated.", data: { check } });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
}

export async function httpShippingAddress(req, res) {
  try {
    const { id } = req.user;
    const { orderId } = req.params;
    // Pull off address from the request
    const validation = shippingAddressSchema.safeParse(req.body);
    if (!validation.success) {
      const { errors } = validation.error;
      console.error({ sellerSetupSchemaError: errors });
      const message = validationErrorBuilder(errors);
      return res.status(400).json({ success: false, message });
    }
    // Store the address
    const updateOrder = await shippingAddress(orderId, {
      ...validation.data,
      id,
    });
    // Update the order shipping address
    return res.status(201).json({
      success: true,
      message: "Shipping address added.",
      data: { updateOrder },
    });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
}

// Payment
// Payment Option
export async function httpPaymentService(req, res) {
  try {
    // Pull off amount payable from orderId
    const { orderId } = req.params;
    const amount = await amountQuery(orderId);
    // Trigger payment option service
    // Update the order payment and status
    const updateOrder = await paymentUpdate(orderId, {
      paymentMethod: "Tradepla Wallet", // To be generated by payment service
      transactionId: "eyJhbGciOiJSUzI1NiI", // To be generated by payment service
    });
    return res.status(200).json({
      success: true,
      message: "Payment successful.",
      data: { updateOrder },
    });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
}

// Delivery
// Rider, Address, Items
export async function httpDeliverOrder(req, res) {
  // Book a ride
  // Strip rider ID and pickup address from ride
  // Update order delivery
  // Update order status "PACKAGED" | "SHIPPING" | "ARRIVED"
}

// Order Confirmation/Receipt
export async function httpOrderCompleted(req, res) {
  try {
    // Update order status
    const { orderId } = req.params;
    const updateOrder = await orderCompleted(orderId);
    return res.status(200).json({
      success: true,
      message: "Order status recorded.",
      data: { updateOrder },
    });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
}

// Review Seller
// Rating, Review, Media
export async function httpReviewSeller(req, res) {
  // Validate the request body (Rating, Review)
  // Validate the request file (media)
  // Review the seller
}

export async function httpGetOrderHistory(req, res) {
  try {
    const { user } = req;
    const { orders, cursor } = await orderHistory({
      placedBy: user.id,
      cursor: req.query?.cursor,
    });
    return res.status(200).json({
      success: true,
      message: "Orders retrieved.",
      data: { orders, cursor },
    });
  } catch (error) {
    console.error({ serverError: error });
    return res.status(500).json({ success: false, message: error.message });
  }
}

export async function httpCompletedOrders(req, res) {
  try {
    const { user } = req;
    const { orders, cursor } = await completedOrders({
      placedBy: user.id,
      cursor: req.query?.cursor,
    });
    return res.status(200).json({
      success: true,
      message: "Orders retrieved.",
      data: { orders, cursor },
    });
  } catch (error) {
    console.error({ serverError: error });
    return res.status(500).json({ success: false, message: error.message });
  }
}
